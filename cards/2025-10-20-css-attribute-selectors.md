---
title: "CSS Attribute Selectors: Targeting Elements by Attribute Values"
date: 2025-10-20
category: selectors
difficulty: intermediate
source: https://developer.mozilla.org/en-US/docs/Web/CSS/Attribute_selectors
author: Olivia Denton
---

# CSS Attribute Selectors: Targeting Elements by Attribute Values

Attribute selectors let you match elements based on the presence or value of HTML attributes. You can select elements that have a given attribute (for example `[disabled]`), match an exact value (`[type="checkbox"]`), or use substring operators: `^=` (starts with), `$=` (ends with), and `*=` (contains). They’re handy when you can’t (or don’t want to) add classes, or when markup already carries meaningful attributes like `data-*`, `role`, or `aria-*`.

Using attribute selectors keeps styles tied to semantics. They work with the cascade and specificity rules just like other selectors and are useful for styling form controls, progressive-enhanced components, or third-party content where you can’t change markup.

## When to Use

- Style components by semantic attributes (e.g., `[aria-pressed="true"]`) instead of toggling classes.
- Target third-party markup or generated content where you can read attributes but not add classes (e.g., `[title]`, `img[alt]`).
- Apply input-specific visuals via `input[type="email"]` or `input[type="tel"]` for better affordances.
- Let JavaScript toggle attributes like `data-open`/`data-state` and have CSS handle the visuals.

## Example

HTML

```html
<button data-state="closed" class="panel-toggle">Open</button>
<button data-state="open" class="panel-toggle">Close</button>
<input type="email" placeholder="you@example.com">
<a href="https://example.com">Example</a>
<span class="icon-heart"></span>
```

CSS

```css
/* presence */
---
title: "CSS Attribute Selectors: Targeting Elements by Attribute Values"
date: 2025-10-20
category: selectors
difficulty: intermediate
source: https://developer.mozilla.org/en-US/docs/Web/CSS/Attribute_selectors
author: Docs Team
---

# CSS Attribute Selectors: Targeting Elements by Attribute Values

Attribute selectors target elements by attribute presence or value. Use `[disabled]` to match presence, `[type="checkbox"]` for exact values, and substring operators like `^=` (starts with), `$=` (ends with), and `*=` (contains). They’re great when markup already expresses meaning via `data-*`, `role`, or `aria-*` attributes and you don’t want extra classes.

They integrate with the cascade and specificity the same as other selectors and are commonly used for form styling, state-driven components, and styling third-party content you can’t modify.

## When to Use

- When semantic attributes exist (e.g., `[aria-pressed="true"]`).
- To style third-party or auto-generated elements you can't change (e.g., `[title]`).
- For form-specific styles (`input[type="email"]`).
- To let JS toggle `data-*` attributes while CSS applies visuals.

## Example

```html
<button data-state="open" class="panel-toggle">Close</button>
<input type="email" placeholder="you@example.com">
```

```css
.panel-toggle[data-state="open"] { background:#e0f7ea }
input[type="email"] { outline:2px solid #6ca0ff }
[class^="icon-"] { display:inline-block; width:1em }
```

## Browser compatibility

Attribute selectors have broad support in modern browsers. Check MDN if you need details for legacy Internet Explorer versions.

## Real-world examples

- Accordions/tabs driven by `data-state`.
- Styling inputs by `type` for better UX.
- Marking external links with `a[href^="http"]`.

**Source**: [MDN: Attribute selectors](https://developer.mozilla.org/en-US/docs/Web/CSS/Attribute_selectors)
- Target elements generated by third-party content where you cannot add classes but can read attributes (e.g., `[title]`).
